using System;

namespace ChocoFactory
{
    // Синглтон-патерн забезпечує існування лише одного об'єкта певного класу і глобальний доступ до нього
    //
    // Використовується, якщо існування кількох об'єктів одного класу створює проблему. (Наприклад об'єкт з даними про
    // користувача) 
    //
    // ЛЕГЕНДА
    // Шоколадна фабрика використовує бойлери для нагрівання шоколаду. Треба не допустити, щоб бойлер нагрівався пустий,
    // або якщо він уже нагрітий
    // 
    // Проблема: інформація про те, чи нагрітий та повний бойлер міститься в одному об'єкті класу. Що станеться, якщо
    // два об'єкти Boiler в нашому класі будуть керувати одним реальним бойлером? Очевидно, нічого хорошого. Для того,
    // щоб проконтролювати єдиність віртуального бойлера, застосуємо Синглтон-патерн


    // Тестовий модуль
    class Program
    {
        static void Main(string[] args)
        {
            BadBoiler badBoiler = new BadBoiler();

            // слідуємо інструкції - наповнюємо -> гріємо -> виливаємо
            badBoiler.Fill(); 
            badBoiler.Boil();
            badBoiler.Drain(); 
            
            badBoiler.Boil(); // Порушили інструкцію, але програма не дала статися аварії - все враховано
            badBoiler.Fill(); // наш бойлер знову повний

            // ... кілька тисяч рядків коду по тому

            badBoiler = new BadBoiler(); // випадково створюємо новий об'єкт BadBoiler, забуваючи, що наш 
            // контейнер в реальному світі УЖЕ ПОВНИЙ! (див. рядок 32)
            badBoiler.Fill(); // АВАРІЯ на фабриці шоколаду. Програма не змогла засікти помилку, адже ми
            // створили новий об'єкт BadBoiler, який вважає, що контейнер пустий (isEmpty = true за замовчуванням!)


            // Використаємо гарно спроектований клас GoodBoiler
            GoodBoiler.getInstance().Fill();
            GoodBoiler.getInstance().Boil();
            GoodBoiler.getInstance().Drain();

            GoodBoiler.getInstance().Fill();
            GoodBoiler.getInstance().Fill();
            GoodBoiler.getInstance().Boil();
            GoodBoiler.getInstance().Boil();

            // Тепер ми фізично не можемо порушити щось в нашій програмі, адже ми не можемо випадково створити
            // новий GoodBoiler і обнулити його дані тим самим.
        }
    }
}
