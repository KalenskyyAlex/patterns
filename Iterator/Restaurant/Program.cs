using System;

// Патерн-ітератор дає доступ до ітерування будь-якого спику, інкапсулюючи його реалізацію
// 
// ЛЕГЕНДА
// Припустимо ми маємо два меню ресторану: напої та страви. Тепер нам треба написати клас офіціанта, який
// би міг цими меню оперувати, і давати повне меню(об'єднане). Але упс! Так як наша команда велика, то меню
// напоїв і меню страв робили різні розробники, і реалізація в них різна. Напої збергіаються в List, а страви - 
// в Stack (не питайте, це просто приклад). Оскільки реалізація різна. Офіціанту доведеться окремо звертатися до
// напоїв і окремо до страв, але ефективність такого коду буде мала, і буде зменшуватися ще більше, якщо ми додамо
// нові меню, наприклад десерти. Чи є спосіб якось узагальнити ітерацію списків, не зважаючи на їх реалізацію?
// На допомогу прийде патерн-ітератор!


// Тестовий модуль
namespace Restaurant
{
    class Program
    {
        static void Main(string[] args)
        {
            IMenu menu1 = new DrinksMenu();
            IMenu menu2 = new MainMenu();

            Waiter waiter = new Waiter(menu2, menu1);

            waiter.printFullMenu();
        }
    }
}
