using System;

// Патерн стратегії - створення "сімейства алгоритмів", 
// створення їх взаємозамінювуваними під час виконання програми
//
// Ми виділяємо найбільш змінювані частини класу, і реалізовуємо їх через інтерефейс,
// лишаючи в класі лише посилання на цей інтерфейс, що дозволяє нам швидко змінювати їх та
// спрощує редагування 

// ЛЕГЕНДА:
//
// Треба створити програму-"гру" яка містить безліч качечок
// 
// Використовуючи найбільш інтуїтивні принципи ООП ми швидко можемо створити базовий клас Duck
// який містить методи swim(), display(), fly() i quack(). Ми і не підозрюємо про проблему, яка на нас
// насувається. Справа в тім, що все працює добре, до того моменту, коли ми вирішуємо додати гумову 
// качечку. Адже вона не вміє літати, а замість крякання пищить. 
//
// Вирішувати цю проблему класичними підходами - писати метод fly i quack для кожного каченяти окремо - 
// дурна і неблагородна ідея, адже в нас буде багато однакових методів, і це знизить життєздатність 
// проекту до 0.
// 
// В цьому випадку краще застосувати патерн стратегії

// Тестовий модуль
namespace DuckUSim
{
    class Program
    {
        static void Main(string[] args)
        {
            Duck duck1 = new ModelDuck();
            duck1.proceedFly();
            duck1.setFlyBehaviour(new FlyableWithRocketBelt());
            duck1.proceedFly();
            duck1.proceedQuack();
            duck1.swim();
            duck1.display();
        }
    }
}
