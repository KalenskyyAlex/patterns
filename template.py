# Ну що ж, давайте зваримо чайку. Або кави. Що в них спільного?
# 1. треба закип'ятити чайник              | спільне 
# 2. вмокнути пакетик чаю / розчинити кави | різне  
# 3. розлити в чашку                       | спільне
# 4. Додати лимон / додати молока, цукру   | різне
# Маємо два спільних пункти і 2 досить схожих пунктів, правда ж?

class Drink:
	def __init__(self):
		pass

	# виконуємо наш рецепт. Це і є наш метод-тімплейт (метод-шаблон)
	def make(self):
		self.boilWater()
		self.brew()
		self.pour()
		if self.clientWantsCondiments():
			self.addCondiments()
		self.done()

	# вода кип'ятиться однаково
	def boilWater(self):
		print("Boiling water...")

	# чайок і кава заварюються по різному - лишимо реалізацію заварювання дочірнім класам
	def brew(self):
		pass # ви здивувалися? це і є "абстрактні" методи на python

	# розливаємо
	def pour(self):
		print("Pouring in the cup...")

	# додаємо лимон або молока та цукру
	def addCondiments():
		pass # ще один "абстрактний" метод від python


	# гоп-гоп це важливо!
	# так звані hook-методи дають нам змогу реалізувати метод всередині класу, з можливістю 
	# його переписати, якщо це треба буде дочірньому класу. Але якщо дочірній клас не хоче,
	# він не зобов'язаний, так, як би мав з абстрактним методом
	def clientWantsCondiments(self):
		return True # за замовчуванням клієнт хоче добавок

	# сповіщаємо клієнта, що все готово
	def done(self):
		print("Done!")

# наслідування в python
class Tea(Drink):
	def brew(self):
		print("Steeping the teabag in the water...")

	def addCondiments(self):
		print("Adding lemon...")

	# ми не переписали cleintWantsCondiments() але і не зобов'яхані, адже це
	# не абстрактний метод. В такому разі його виконає наш головний клас

class Coffee(Drink):
	def brew(self):
		print("Brewing coffee in the water...")

	def addCondiments(self):
		print("Adding milk and sugar...")


	# виключно за потребами класу ми переписали clientWantsCondiments()
	# Замість реалізації за замовчуванням тепер реалізація дочірнього класу
	def clientWantsCondiments(self):
		answer = input("Do you want sugar & milk?")
		if "y" in answer.lower():
			return True
		else:
			return False

# Нумо тестити
coffee = Coffee()
coffee.make()

tea = Tea()
tea.make()

# для чого це треба? Ми могли б зробити так:
# лишити boil() i pour() абстрактними, а make() віддати на виконання дочірнім класам. Чому ми лишили реалізацію головному класу Drink?
# - бо ми хочемо контролювати процес готування
# - зміна такого простого рецепту, наприклад розбавляти готовий напій водою, як це роблять недобросовісні підприємці, змусить робити зміну в КОЖНОМУ дочірньому класі
# - бо все таки make() у всіх дочірніх класах на 50% ідентичний. Для чого нам кожного разу повторювати 50% коду?
# Натомість краще зробити метод-шаблон. Особливості такого методу: 
# - він КОНТРОЛЮЄ роботу алгоритму, і лише іноді дозволяє дочірнім класам частково реалізувати алгоритм
# тобто
# - він містить спільне для кожного дочірнього класу
# - в той же час ті ділянки алгоритму, які для дочірніх класів різняться, він ІНКАПСУЛЮЄ в абстрактні методи
# Структура такого методу:
# - конкретні методи, які реалізує сам клас
# - абстрактні методи, які реалізують дочірні класи
# - hook-методи, які може раелізовувати як головний клас, так і його дочірні класи, якщо переозначать його