using System;
using System.Windows.Forms;

// Уявімо, що нам треба якимось чином завантажити важку якісну картинку з інтернету. Що буде, якщо ми це зробимо?:
//  1. Ми вантажимо все в одному треді, бо не шаримо за парельне програмування
//  2. Клієнт 10 годин дивиться на пустий екран, і програма "висить"
//  3. Клієнт задовбався і не дочекався
//
// Як ми можемо зарадити?
//  - швидкісний інет ми за свій рахунок проводити не будемо, але
//  - можемо зробити видимість завантаження, щоб клієнт розумів, що комп не помер
//
// Тому ми цим і займемося.
// Як нам це зробити?
//  - вставити логіку "очікування" в ImageFinder - даю оцінку 'крінж'
//  - використати проксі патерн - оце вже круто
//
// Як я вже казав, проксі патерн це не тільки про мережеві зв'язки. Минулого разу ми розглянули саме такий його варіант,
// який називається REMOTE Proxy (віддалений), що логічно. Тепер ми будемо використовувати VITUAL Proxy
//
// Фішки Virtual Proxy
// - імітує роботу справжнього об'єкта
// - ховає в собі справжній об'єкт
//      - контролює доступ
//      - контролює виконання
// але це все робить БУДЬ-ЯКИЙ проксі, а особливістю цього є те, що
// - Клієнт/Проксі/Об'єкт знаходяться в одній аплікації, на відміну від поперднього прикладу
// - Об'єкт це (дуже ресурсовитратний об'єкт)/(об'єкт, який довго опрацьовує операції), створювати який кожного разу важко
// 
// Розпізнаємо:
// ImageFinder вантажить великі файли, тому його можна назвати "великим" об'єктом
// Тому ми загорнемо його в швидкий ImageFinderProxy, який буде керувати програмою, доки ImageFinder "думає"
// 
// Поїхали!


// Тестимо
namespace ImageLoader
{
    public partial class ImageLoader : Form
    {
        public ImageLoader()
        {
            InitializeComponent();
            Image.SizeMode = PictureBoxSizeMode.StretchImage; // щоб картинку не жмихало
        }

        private void GetImage_Click(object sender, EventArgs e)
        {
            // Спробуйте викликати ImageFinder напряму і ви помітите, що зображення високої якості
            // вимагають трохи часу, аби завантажитися. В цей час вікно просто буде "висіти", і це
            // не дуже то й презентабельно.
            // 
            //  IImageFinder finder = new ImageFinder(new int[2] {2000, 2000});
            //  Image.Image = finder.findImage();
            // 
            // натомість ми викликаємо проксі ImageFinderProxy, який контролює, щоб доки наш 
            // дуже "дороговартісний" об'єкт думає, користувач бачив напис "Loading..."


            // натомість наш проксі трошки прикрашає цей процес
            // Що він робить?
            // - контролює доступ до справжнього ImageFinder'a  
            // - використовує його функціонал, щоб імітувати роботу
            // - малозатратний - працює зразу, на відміну від ImageFinder'a
            // - дає нам прикольну візуальну фішку, щоб не просто дивилися на пустий екран
            ImageFinder finder = new ImageFinder(new int[] { 2000, 2000 }); 
            IImageFinder finderProxy = new ImageFinderProxy(finder, Image);
            Image.Image = finderProxy.findImage();
        }


        // зробимо цю програму трохи більш корисною, і додамо можливість зберігати фото, що сподобалися
        // *не пов'язано з патерном*
        private void Save_Click(object sender, EventArgs e)
        {
            SaveFileDialog dialog = new SaveFileDialog();
            dialog.Title = "Save Current Image";
            dialog.FileName = "untitled";
            dialog.DefaultExt = "png";
            if(dialog.ShowDialog() == DialogResult.OK)
            {
                if (dialog.FileName != "")
                {
                    System.IO.FileStream fs = (System.IO.FileStream)dialog.OpenFile();

                    Image.Image.Save(fs, System.Drawing.Imaging.ImageFormat.Png);

                    fs.Close();
                }
            }
        }
    }
}
